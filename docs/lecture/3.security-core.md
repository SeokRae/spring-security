# 3. 시큐리티 주요 아키텍처 이해 

## 3.1. Proxy

### 3.1.1. DelegatingFilterProxy & FilterChainProxy
- DelegatingFilterProxy & FilterChainProxy 생성 및 등록 Flow
    - SecurityFilterAutoConfiguration
        - 63 Line: DelegatingFilterProxyRegistrationBean registration = new DelegatingFilterProxyRegistrationBean(DEFAULT_FILTER_NAME);
            - springSecurityFilterChain 이름으로 DelegatingFilerProxy 를 생성
        - DelegatingFilterProxy
            - 165 Line: public DelegatingFilterProxy(String targetBeanName, @Nullable WebApplicationContext wac) {
                - springSecurityFilterChain: DelegatingFilerProxy 형태로 **Filter 생성**
        - WebSecurityConfiguration
            - 94 Line: @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)
                - **springSecurityFilterChain 명으로 Bean**을 등록
            - 95 Line: public Filter springSecurityFilterChain() throws Exception {
                - FilterChainProxy를 생성
        - WebSecurity
            - 279 Line: protected Filter performBuild() throws Exception {
            - 296 Line: FilterChainProxy filterChainProxy = new FilterChainProxy(securityFilterChains);
                - **FilterChainProxy를 Bean생성** 및 등록

- DelegateFilterProxy & FilterChainProxy 요청 Flow
    - DelegatingFilterProxy
        - 254 Line: public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)
            - 위임할 Filter를 찾는다. (springSecurityFilterChain)
        - 264 Line: delegateToUse = initDelegate(wac);
            - 338 Line: Filter delegate = wac.getBean(targetBeanName, Filter.class);
                - AnnotationConfigServletWebServerApplicationContext으로부터 getBean() 하여 springSecurityFilterChain라는 이름의 Bean을 가져옴
                - 가져온 Bean은 FilterChainProxy
        - 271 Line: invokeDelegate(delegateToUse, request, response, filterChain);
            - 요청을 위임
            - 358 Line: delegate.doFilter(request, response, filterChain);
                - FilterChainProxy를 호출
    - FilterChainProxy
        - 172 Line: public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
            - DelegatingFilterProxy의 request를 전달
            - 보안 처리를 실시함
        - 190 Line: private void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
            - securityFilter의 리스트를 가져와 보안 처리를 수행
            - 198 Line: List<Filter> filters = getFilters(fwRequest);
                - securityFilter 리스트를 호출
            - 214 Line: VirtualFilterChain vfc = new VirtualFilterChain(fwRequest, chain, filters);
                - FilterChain 내부적으로 가상 VirtualFilterChain을 생성하여 내부적으로 실질적으로 request 처리를 수행함
                - VirtualFilterChain
                    - 325 Line: Filter nextFilter = additionalFilters.get(currentPosition - 1);
                        - 설정된 securtyFilterChain을 관리 및 호출하여 request에 대한 보안처리를 수행함
                        - 요청을 완로하고나서 Servlet으로 이동

## 3.2. 필터 초기화와 다중 보안 설정

### 3.2.1. 필터 초기화 및 다중 설정 클래스
- 다중 설정이 필요한 이유 ?
    - 요청 방식에 따라 다른 보안 방식이 필요하는 경우에 사용한다.

- 다중 설정 시 처리 방식
    - requestMatcher 에 따라 다른 Filter 사용

- 다중 설정 시 설정 순서
    - requestMatcher에 따라 Filter Flow가 다르기 때문에 상세한 requestMapping 부터 선언하도록 한다.
    - 넓은 범위의 requestMapping부터 선언 시 세부적으로 설정해야 할 경로의 보안이 무시되는 이슈가 발생할 수 있음

```
@Order(0)
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {

        http.
                /* 3.1.1. 필터 초기화 및 다중 보안 설정 용 */
                .antMatcher("/admin/**")
                .authorizeRequests()
                .anyRequest().authenticated()
            .and()
                .httpBasic();
    }
}
```

```
@Order(1)
@Configuration
public class SecuritySubConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        /* 3.1.1. 필터 초기화와 다중 보안 설정 */
        http
                .authorizeRequests()
                .anyRequest().permitAll()
            .and()
                .formLogin();
    }
}
```

## 3.3. Authentication

- Authentication
    - 사용자의 인증 정보를 저장하는 토큰 개념
        - 인증 시 Id와 Password를 담고 인증 검증을 위해 전달되어 사용된다.
        - 인증 후 최종 적으로 인증 결과(User, 권한정보)를 담고 SecurityContext에 저장되어 전역적으로 참조가 가능하다.

```
Authentication authentication = SecurityContextHolder.getContext().getAuthentication()
```

- 구조
    - principal: 사용자 아이디 혹은 User 객체를 저장
    - credential: 사용자 비밀번호
    - authorities: 인증된 사용자의 권한 목록
    - details: 인증 부가 정보
    - Authenticated: 인증 여부

![Authentication 인증 Flow](/docs/img/flow/flow_Authentication.png)

## 3.4. SecurityContextHolder, SecurityContext

- SecurityContext
    - Authentication 객체가 저장되는 보관소로 필요시 언제든지 Authentication 객체를 꺼내어 쓸 수 있도록 제공되는 클래스
    - ThreadLocal 에 저장되어 아무 곳에서나 참조가 가능하도록 설계됨
    - 인증이 완료되면 HttpSession 에 저장되어 어플리케이션 전반에 걸쳐 전역적인 참조가 가능하다.

- SecurityContextHolder
    - SecurityContext 객체 저장 방식
        - MODE_THREADLOCAL: 스레드당 SecurityContext 객체를 할당, 기본값
        - MODE_INHERITABLETHREADLOCAL: 메인 스레드와 자식 스레드에 관하여 동일한 SecurityContext를 유지
            - 기본적으로는 메인 스레드와 자식 스레드간 영역이 달라 공유하고 있지 않음
        - MODE_GLOBAL: 응용 프로그램에서 단 하나의 SecurityContext 를 저장 (static 변수로 저장)
    - SecurityContextHolder.clearContext() : SecurityContext 기존 정보 초기화


- 시나리오 정리 
    - MainThread와 SubThread의 ThreadLocal의 영역이 독립적인 것을 확인하기 위한 시나리오
        - SecurityContextHolder의 기본 전략 모드인 ThreadLocal과 InheritableThreadLocal 모드를 비교하여 Thread 간 SecurityContext가 관리되는 방식을 확인 

```
    @GetMapping("/")
    public String index(HttpSession session) {

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        SecurityContext context = (SecurityContext) session.getAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY);
        Authentication sessionContext = context.getAuthentication();

        return "Hello World";
    }

    @GetMapping("/thread")
    public String thread() {
        new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        /* ThreaLocal 모드에서는 인증 객체가 null, InheritableThreadLocal 모드의 경우 Thread간 인증 객체가 공유 가능 한 것을 확인 */
                        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
                    }
                }
        ).start();
        return "thread";
    }
```

![SecurityContext](/docs/img/flow/flow_SecurityContext.png)

### 3.4.1. SecurityContextHolder
- SecurityContextHolder
    - 96 Line: private static void initialize() { ... }
        - SecurityContext 객체를 저장하는 방식
            1. MODE_THREADLOCAL
                - 각 Thread간 ThreadLocal에 저장되어 있는 SecurityContext는 또 다른 Thread와 독립적으로 관리한다.
                
            2. MODE_INHERITABLETHREADLOCAL
                - MainThread내에 SubThread간 ThreadLocal이 공유되어 SecurityContextHolder에 접근하여 동일한 SecurityContext를 저장 및 호출할 수 있다.

            3. MODE_GLOBAL : GlobalSecurityContextHolderStrategy
        - xxxSecurityContextHolderStrategy 라는 각각의 전략 클래스명으로 SecurityContext 를 관리 

- SecurityContextHolder 요약
    1. SecurityContext 관리
        - clearContext
        - getContext
        - setContext
        - createEmptyContext

    2. 세 가지 SecurityContextStrategy의 구현체를 설정 가능
        - MODE_THREADLOCAL : ThreadLocalSecurityContextHolderStrategy
        - MODE_INHERITABLETHREADLOCAL : InheritableThreadLocalSecurityContextHolderStrategy
        - MODE_GLOBAL : GlobalSecurityContextHolderStrategy

### 3.4.2. SecurityContext
- SecurityContext (interface)

    - SecurityContext 객체에 접근하는 방법 2가지
        1. SecurityContextHolder
        2. HttpSession

    - SecurityContextHolder에 있는 SecurityContext에 접근하는 방법
        1. Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        2. HttpSession 에 있는 SecurityContext에 접근하는 방법
            - SecurityContext context = (SecurityContext) session.getAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY)
            - Authentication authentication = context.getAuthentication();
        
- SecurityContextImpl (class)

- SecurityContext 요약
    1. Authentication 관리 
        - equals
        - hashCode
        - toString
        - getAuthentication
        - setAuthentication

## 3.5. SecurityContextPersistenceFilter

-  SecurityContext 객체의 생성, 저장, 조회
    1. 익명 사용자를 처리하는 방식
        - 새로운 SecurityContext 객체를 생성하여 SecurityContextHolder 에 **저장**
        - AnonymousAuthenticationFilter에서 AnonymousAuthenticationToken 객체를 SecurityContext 에 저장

    2. 익명 사용자가 인증 시
        - 새로운 SecurityContext 객체를 생성하여 SecurityContextHolder에 **저장**
        - form인증 방식의 UsernamePasswordAuthenticationFilter 에서 인증 성공 후 SecurityContext 에 UsernamePasswordAuthenticationToken 객체를 SecurityContext에 저장
        - 인증이 최종 완료되면 Session 에 SecurityContext을 저장

    3. 인증 후
        - HttpSession에서 SecurityContext 내에 Authentication을 **꺼내어** SecurityContextHolder에 **저장**
        - SecurityContext 안에 Authentication 객체가 존재하면 계속 인증을 유지
        
    4. 최종 응답 시 공통
        - SecurityContextHolder.clearContext()
            - 매 요청마다 SecurityContextHolder의 SecurityContext를 비워준다.

- 익명 사용자를 처리하는 Flow 정리
    -  SecurityContextPersistenceFilter
        - 100 Line: SecurityContext contextBeforeChainExecution = repo.loadContext (holder);
            - 사용자가 이전에 인증에 성공하여 securityContext를 session에 저장한 정보가 있는지 확인
            - HttpSessionSecurityContextRepository
                - 108 Line: public SecurityContext loadContext(httpRequestResponseHolder requestResponseHolder) { ... }
                    - request, response, session을 생성 session으로부터 SecurityContext의 존재여부를 확인 및 조회
                - 120 Line: context = generateNewContext();
                    - 익명의 사용자는 인증한 이력이 없기 때문에 securityContext를 생성
                    
                    - 224 Line: protected SecurityContext generateNewContext()
                    - 225 Line: SecurityContextHolder.createEmptyContext()
                        - SecurityContextHolder
                            - 161 Line: return strategy.createEmptyContext();
                                - InheritableThreadLocalSecurityContextHolderStrategy
                                    - 60 Line: return new SecurityContextImpl();
                                        - SecurityContext를 생성
                                    - 54 Line: public void setContext(SecurityContext context);
                                    - 56 Line: contextHolder.set(context);
                                        - SecurityContext를 저장

        - 103 Line: SecurityContextHolder.setContext(contextBeforeChainExecution);
            - 익명 사용자의 요청 정보로 인하여 생성된 SecurityContext를 SecurityContextHolder에 저장
        - 105 Line: chain.doFilter(holder.getRequest(), holder.getResponse);
            - SecurityContext를 생성 및 저장한 뒤 다음 필터로 이동

        - AnonymousAuthenticationFilter
            - 95 Line: if(SecurityContextHolder.getContext().getAuthentication() == null) { ... }
                - 익명 사용자의 접근으로 인하여 Authentication 값이 null 이기 때문에 익명 사용자용 인증처리 로직이 실행
            - 114 Line: AnonymousAuthenticationToken auth = new AnonymousAuthenticationFilter(key, principal, authorities);
                - 익명 객체 토큰을 생성
            - 96 Line: SecurityContextHolder.getContext.setAuthentication(createAuthentication((HttpServletRequest) req));
                - 바로 위에서 만든 익명 객체 토큰 값으로 AnonymousAuthentication을 생성하여 SecuriryContextHodler의 SecurityContext에 Authentication으로 저장
                
        - 113 Line: SecurityContextHolder.clearContext();
            - 익명 사용자의 경우 SecurityContext를 별도로 저장하지 않고 응답 하기전에 SecurityContextHolder 내에 SecurityContext를 삭제한다.
            - **매 요청바다 SecurityContext를 생성, SecurityContextHolder에 저장하여 Filter간 인증 정보를 확인하기 때문에 계속 저장할 필요가 없음**

        - 114 Line: repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());
        - 134 Line: public void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) { ... }

- 익명 사용자를 처리하는 Flow

![SecurityContextPersistenceFilter_AnonymousCase](/docs/img/flow/flow_SecurityContextPersistenceFilter_AnonymousCase.png)

- 인증 요청 사용자를 처리 flow 정리
    -  SecurityContextPersistenceFilter
        - 100 Line: SecurityContext contextBeforeChainExecution = repo.loadContext (holder);
            - 사용자가 이전에 인증에 성공하여 securityContext를 session에 저장한 정보가 있는지 확인
            - HttpSessionSecurityContextRepository
                - 108 Line: public SecurityContext loadContext(httpRequestResponseHolder requestResponseHolder) { ... }
                    - request, response, session을 생성 session으로부터 SecurityContext의 존재여부를 확인 및 조회
                - 120 Line: context = generateNewContext();
                    - 처음 인증하는 사용자는 인증한 이력이 없기 때문에 securityContext를 생성
                    - 224 Line: protected SecurityContext generateNewContext()
                    - 225 Line: SecurityContextHolder.createEmptyContext()
                        - SecurityContextHolder
                            - 161 Line: return strategy.createEmptyContext();
                                - InheritableThreadLocalSecurityContextHolderStrategy
                                    - 60 Line: return new SecurityContextImpl();
                                        - SecurityContext를 생성
                                    - 54 Line: public void setContext(SecurityContext context);
                                    - 56 Line: contextHolder.set(context);
                                        - SecurityContext를 저장
        - 103 Line: SecurityContextHolder.setContext(contextBeforeChainExecution);
                - 인증되지 않은 사용자의 요청 정보로 인하여 생성된 SecurityContext를 SecurityContextHolder에 저장
        - 105 Line: chain.doFilter(holder.getRequest(), holder.getResponse);
            - SecurityContext를 생성 및 저장한 뒤 다음 필터로 이동
            
        - ... 인증 필터가 인증 처리를 한 뒤 인증 성공 후 

        - AbstractAuthenticationProcessingFilter
            -  307 Line: protected void successfulAuthentication( ... ) { ... }
                - 인증 필터에서 인증 처리 후 인증 성공 시 처리되는 메서드
                - 316 Line: SecurityContextHolder.getContext().setAuthentication(authRequest);
                    - 인증이 성공된 인증 객체를 SecurityContext에 저장
                    
        - HttpSessionSecurityContextRepository
            - 344 Line: protected void saveContext (SecurityContext context) { ... }
                - 인증이 최종 완료되면 Session에 SecurityContext를 저장
            - 349 Line: if(authentication == null || trustResolver.isAnonymous(authentication)) { ... }
                - 익명 사용자가 아닌경우
            - 368 Line: if(httpSession != null) { ... }
            - 373 Line: httpSession.setAttribute(springSecurityContextKey, context);
                -  HttpSession 에 SecurityContext를 저장
        - 113 Line: SecurityContextHolder.clearContext();
            - 응답 하기전에 SecurityContextHolder 내에 SecurityContext를 삭제한다.
            - **매 요청바다 SecurityContext를 생성, SecurityContextHolder에 저장하여 Filter간 인증 정보를 확인하기 때문에 계속 저장할 필요가 없음**

        - 114 Line: repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());
        - 134 Line: public void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) { ... }
        
        * 정상 인증 처리된 Authentication은 SecurityContext에 저장되어 Session이 관리하게 되는 형태

- 인증 요청 사용자를 처리하는 Flow

![SecurityContextPersistenceFilter_UnAuthenticationUser](/docs/img/flow/flow_SecurityContextPersistenceFilter_UnAuthenticationUser.png)

- 정상 인증 처리된 사용자가 요청 flow 정리
    -  SecurityContextPersistenceFilter
        - 100 Line: SecurityContext contextBeforeChainExecution = repo.loadContext (holder);
            - 사용자가 이전에 인증에 성공하여 securityContext를 session에 저장한 정보가 있는지 확인
            - HttpSessionSecurityContextRepository
                - 108 Line: public SecurityContext loadContext(httpRequestResponseHolder requestResponseHolder) { ... }
                    - request, response, session을 생성 session으로부터 SecurityContext의 존재여부를 확인 및 조회
        - 103 Line: SecurityContextHolder.setContext(contextBeforeChainExecution);
                - 인증된 사용자의 정보는 SecurityContext에 이미 존재하여 현재 필터에서 사용될 SecurityContextHolder에 저장되어 공유할 수 있도록 한다.
 
        - 105 Line: chain.doFilter(holder.getRequest(), holder.getResponse);
            - 공유할 SecurityContext를 Holder에 저장한 뒤 다음 필터로 이동
    
        - 113 Line: SecurityContextHolder.clearContext();
            - 응답 하기전에 SecurityContextHolder 내에 SecurityContext를 삭제한다.
            - **매 요청바다 SecurityContext를 생성, SecurityContextHolder에 저장하여 Filter간 인증 정보를 확인하기 때문에 계속 저장할 필요가 없음**

        - 114 Line: repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());
        - 134 Line: public void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) { ... }

- 인증 처리된 사용자의 요청 Flow

![SecurityContextPersistenceFilter_AuthenticationUser](/docs/img/flow/flow_SecurityContextPersistenceFilter_AuthenticationUser.png)

## 3.6. Authentication


- Authentication 인증 Flow Debug
    - UsernamePasswordAuthenticationFilter
    - AuthenticationManager
    - AuthenticationProvider
        - UserDetailsService
            - Repository
        

- Authentication 인증 Flow 

![AuthenticationManager](/docs/img/flow/flow_AuthenticationManager.png)

## 3.6.1. AuthenticationManager Basic

## 3.6.2. AuthenticationManager Advance


## 3.7. AuthenticationProvider


## 3.8. Authorization, FilterSecurityInterceptor

### 3.8.1. Authorization

### 3.8.2. FilterSecurityInterceptor


## 3.9. AccessDecisionManager, AccessDecisionVoter

### 3.9.1. AccessDecisionManager Basic

### 3.9.2. AccessDecisionVoter Basic

### 3.9.3. AccessDecisionManager Advance

### 3.9.4. AccessDecisionVoter Advance

## 3.10 스프링 시큐리티 필터 및 아키텍처 정리