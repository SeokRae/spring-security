# 2. 스프링 시큐리티 기본 API & Filter 이해

## 2.1. 인증 API

### 2.1.1. 프로젝트 구성 및 의존성 추가 

- 서버가 기동되면 스프링 시큐리티의 초기화 작업 및 보안 설정이 이루어진다
    - 별도의 설정이나 구현을 하지 않아도 기본적인 웹 보안 기능이 현재 시스템에 연동되어 작동함
    - 모든 요청은 인증이 되어야 자원에 접근이 가능하다
        1. 인증 방식은 폼 로그인 방식과 httpBasic 로그인 방식을 제공한다
        2. 기본 로그인 페이지 제공한다
        3. 기본 계정 한 개 제공한다 – username : user / password : 랜덤 문자열

- 개선할 사항
    - 계정 추가
    - 권한 추가
    - DB 연동
    - 기본적인 보안 기능 외에 시스템에서 필요로 하는 더 세부적이고 추가적인 보안기능이 필요

### 2.1.2. 사용자 정의 보안 기능 구현

- WebSecurityConfigurerAdapter (핵심)
    - 웹 보안 기능 초기화 및 활성화
    - HttpSecurity 생성
        - 인증 & 인가 API 제공

- WebSecurityConfigurerAdapter
![WebSecurityConfigurerAdapter](/docs/img/diagram/diagram_WebSecurityConfigurerAdapter.png "WebSecurityConfigurerAdapter")

- HttpSecurity
![HttpSecurity](/docs/img/diagram/diagram_HttpSecurity.png "HttpSecurity")

- [SecurityConfig.java](/security-basic-api/src/main/java/kr/seok/SecurityConfig.java)

- Debug
```
- SecurityConfig Debug
    1. WebSecurityConfigurerAdapter 클래스의 기본 값 설정 디버깅

    2. HttpSecurity 기본 설정
        1) getHttp()
        2) configure()

```

### 2.1.3. HTTP Basic 인증

```
- Http는 자체적인 인증 관련 기능을 제공하며 HTTP 표준에 정의된 가장 단순한 인증 기법이다.
- 간단한 설정과 Stateless가 장점 - Session Cookie(JESSIONID) 사용하지 않음
- 보호차원 접근 시 서버가 클라이언트에게 401 UnAuthorized 응답과 함께 WWW-Authenticate header를 기술해서 인증 요구를 보냄
- Client Id: Password 값을 Base64로 Encoding한 문자열을 Authorization Header에 추가한 뒤 Server에게 Resource를 요청
    - Authorization: Basic cmVzdDpyZXN0
- ID, Password가 Base64로 Encoding되어 있어 ID, Password가 외부에 쉽게 노출되는 구조이기 때문에 SSL이나 TLS는 필수이다.
```

### 2.1.4. BasicAuthenticationFilter

- [RFC 7617](https://tools.ietf.org/html/rfc7617)
    - ![RFC 7617 Diagram](/docs/img/flow/flow_BasicAuthenticationFilter.png)

- 인증 프로토콜과 헤더
```
- HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.
- 헤더의 형식과 내용은 인증 프로토콜에 따라 달라진다.
- 인증 프로토콜은 HTTP 인증 헤더에 기술되어 있다.
- HTTP에는 "기본 인증"과 "DIGEST 인증"이 있다.
```

- Basic Authentication 의 문제점
```
- 기본 인증의 보안 문제
    - 기본 인증은 단순하고 편리하지만 안심할 수 없다.
    - 기본인증은 악의적이지 않은 누군가가 의도하지 않게 리소스에 접근하는 것을 막는데 사용하거나 SSL 같은 암호 기술과 혼용 해야 한다.
    - base64 인코딩된 값은 쉽게 디코딩할 수 있다.
    - 제 3자는 사용자 이름과 비밀번호를 캡처하여 악용할 수 있다.
    - Proxy나 중개자가 개입하는 경우 정상적인 동작을 보장할 수 없다.
    - 기본인증은 가짜 서버의 위장에 취약하다.
```

### 2.1.5. Form 인증
- 인증 API
    - formLogin() 사용 시 FormLoginConfigurer 설정 등록
    - FormLoginConfigurer 설정 시 UserPasswordAuthenticationFilter 등록

```
- 인증
    - formLogin()
    - loginPage("/loginPage")
        - 스프링 시큐리티의 기본 로그인 페이지를 설정
    - defaultSuccessUrl("/")
        - 로그인 성공 시 redirect 되는 URL 설정
    - usernameParameter("userId")
        - 로그인 기본페이지의 username 의 name 값을 설정
    - passwordParameter("passwd")
        - 로그인 기본페이지의 password 의 name 값을 설정
    - loginProcessingUrl("/login_proc")
        - ?
    - successHandler(new AuthenticationSuccessHandler() {})
        - 로그인 성공 시 실행되는 Handler
    - failureHandler(new AuthenticationFailureHandler() {})
        - 로그인 실패 시  실행되는 Handler
    - permitAll()
        - formLogin에 접근하기 위한 url의 접근 권한 all 설정
```

### 2.1.6. UserPasswordAuthenticationFilter
- Authentication
    - 인증을 처리하는 필터

![UsernamePasswordAuthenticationFilter](/docs/img/flow/flow_UsernamePasswordAuthenticationFilter.png)

### 2.1.7. Logout, LogoutFilter
- LogoutFilter Flow

![LogoutFilter](/docs/img/flow/flow_LogoutFilter.png)

- Logout
    - request("/logout")
    - 세션 무효화
    - 인증 토큰 삭제
    - 쿠키정보 삭제,
    - 로그인 페이지로 리다이렉트

### 2.1.8. Remember Me 인증

- RememberMe 인증이란 대체 뭐야 ?
    - form 인증 방식에 추가로 사용할 수 있는 기능
        - 세션이 유실 또는 웹 브라우저가 종료된 이후에도 어플리케이션이 사용자를 기억하는 기능

- remember-me cookie 란?
    - 발급 조건
        - remember-me 기능을 활성화시킨 상태에서 인증 프로세스를 처리 시 서버가 remember-me 쿠키를 응답 헤더에 실어서 보내게 된다.
    - 용도
        - 사용자는 remember-me 쿠키의 만료일 전까지 세션 유지가 가능하다.
        - 세션이 유실되는 경우에도 remember-me 쿠키가 존재하는 경우 쿠키 안에 사용자 정보를 통해 토큰 기반 인증하여 토큰 검증 시 로그인 유지가 가능
    - 쿠키에 존재하는 remember-me 형태
    
![RememberMe 생성 확인](/docs/img/browser/rememberMe.png)

- 라이프 사이클
    - 인증 성공
        - remember-me 쿠키 설정
    - 인증 실패
        - 쿠키 존재 시 쿠키 무효화
    - 로그 아웃
        - 쿠키 존재 시 쿠키 무효화

- 로그인 시 세션 생성 플로우
- JSESSIONID 삭제 시 remember-me 쿠키가 인증 토큰을 재발급 하는 플로우

![RememberMe Flow](/docs/img/flow/flow_RememberMe.png)

### 2.1.9. RememberMeAuthenticationFilter

- remember-me 발급 플로우

![RememberMeFilter Flow](/docs/img/flow/flow_RememberMeFilter.png)

- Remember-Me가 존재하는 경우 JSESSIONID가 유실되는 경우에도 인증처리가 가능
    - SpringSecurity의 RememberMeAuthenticationFilter 에서 request Header에 Cookie를 확인하여 userId와 userPw값으로 user 객체를 얻어 인증처리 해버림

### 2.1.10. AnonymousAuthenticationFilter
- 사용자의 인증 여부를 판단하는 필터
- 인증 받지 않은 사용자에게 Authentication == null 이 아닌 '익명 사용자용 인증객체' 를 담도록 하는 필터
- 접근한 유저 정보의 인증정보를 null 이 아닌 익명 사용자로 확인 가능
    - isAnonymous() 인 경우 loginPage로 접근할 수 있도록 유도 가능
    - isAuthenticated() 인 경우 logoutPage로 접근 할 수 있도록 유도 가능

- AnonymousAuthenticationFilter 에서 인증객체 확인 및 익명 객체 설정 기능
- 위 처리를 하게 되는 경우 AbstractSecurityInterceptor 에서 익명객체를 확인하여 인가 처리를 하게 됨

- 익명 객체 flow

![AnonymousFilter](/docs/img/flow/flow_AnonymousFilter.png)

### 2.1.11. 동시적 세션 제어 전략
- 동일 계정으로 접속이 허용되는 최대 세션 수를 제한
    - 이전 세션 종료 방식
    - 이후 세션 접근 거부 방식

```
/* 세션 관리 */
.sessionManagement()
    .maximumSessions(1) // 최대 허용 가능 세션 수 (-1: 무제한)
    .maxSessionsPreventsLogin(true) // 동시 로그인 차단 (default: false)
    .expiredUrl("/login") // 세션 만료 시 페이지 이동
/* 세션 관리 */
.sessionManagement()
    .invalidSessionUrl("/login") // 세션 유효하지 않는 경우 페이지 이동
```    

### 2.1.12. 세션 고정 보호
- 인증 할 때마다 세션 쿠키를 새로 발급하여 공격자의 쿠키 조작을 방지 
- 사용자의 쿠키를 공격자의 쿠키로 인증처리 한 뒤 공격자가 해당 쿠키로 인증하는 세션 고정 공격을 방지 하기 위한 설정

```
/* 세션 고정 보호 설정 */
.sessionFixation()

    /* 세센 고정 보호를 사용하지 않는 경우 위와 같은 문제가 발생할 수 있음 */
     .none()

    /* Servlet 3.1 미만 버전 일 때 default 값 */
    /* 세션을 생성하되 기존 세션 정보가 있다면 사용할 수 있음 */
     .migrateSession()
    
    /* 새로운 인증 세션으로 변경하는 방법 */
     .newSession()

    /* Servlet 3.1 이상 버전 일 때 default 값 */
    /* 세션을 생성하되 기존 세션 정보가 있다면 사용할 수 있음 */
    .changeSessionId()
```

### 2.1.13. 세션 정책
- 세션 정책
    - Always
    - if_Required
    - Never
    - Stateless

### 2.1.14. SessionManagementFilter
1. 세션 관리
    - 인증 시 사용자의 세션 정보를 등록, 조회, 삭제 등의 세션 이력을 관리

2. 동시적 세션 제어
    - 동일 계정으로 접속이 허용되는 최대 세션 수를 제한
    - ConcurrentSessionControlAuthenticationStrategy
    
3. 세션 고정 보호
    - 인증 할 때마다 세션 쿠키를 새로 발급하여 공격자의 쿠키 조작을 방지
    - ChangeSessionIdAuthenticationStrategy
     
4. 세션 생성 정책
    - Always, if_Required, Never, Stateless

### 2.1.15. ConcurrentSessionFilter
- 매 요청마다 현재 사용자의 세션 만료 여부 체크
- 세션이 만료되었을 경우 즉시 만료 처리
- session.isExpired() == true
    - 로그아웃 처리
    - 즉시 오류 페이지 응답

- check point
    - 동시적 세션 제어를 처리하기위해 ConcurrentSessionFilter와 SessionManagementFilter의 처리과정을 살펴볼 것

- 시나리오
    1. Session의 등록
    2. 동일 계정 접속 시 세션 처리 방식
        - 인증 실패 전략
        - 세션 만료 전략
        
### 2.1.16. 권한 설정

### 2.1.17 표현식

## 2.2. 인증 / 인가 API

### 2.2.1. ExceptionTranslationFilter

### 2.2.2. AuthenticationException

### 2.2.3. AccessDeniedException

### 2.2.4. RequestCacheAwareFilter